defmodule QuadblockquizWeb.VulnerabilityTest do
  use QuadblockquizWeb.ConnCase
  alias Quadblockquiz.QnA
  import Phoenix.LiveViewTest
  alias Quadblockquiz.Test.Auth

  setup do
    conn = Auth.login()

    bottom = %{
      {1, 20} => {1, 20, :blue},
      {1, 19} => {1, 19, :blue},
      {1, 18} => {1, 18, :blue},
      {1, 17} => {1, 17, :blue}
    }

    assigns = %{
      __changed__: %{},
      contest: %{name: "contestQ", id: 22},
      bottom: bottom,
      brick: Quadblockquiz.Brick.new_random(),
      current_user: %{uid: 40_000_000},
      score: 0,
      speed: 2,
      state: :playing,
      tick_count: 1,
      qna: QnA.question(["qna"], "open_c2"),
      row_count: 0,
      brick_count: 1,
      attack_threshold: 5,
      lawsuit_threshold: 5,
      vuln_threshold: 79,
      tech_vuln_debt: 45,
      lic_threshold: 81,
      tech_lic_debt: 0,
      hint: :intro,
      start_time: ~U[2021-04-20 06:00:53Z],
      correct_answers: 0,
      contest_id: 22,
      used_powers_count: 0,
      available_powers_count: 0,
      powers: []
    }

    [assigns: assigns, bottom: bottom, conn: conn]
  end

  describe "Bottom Vulnerability:" do
    test "tech_vuln_debt increases on clock tick", %{assigns: assigns} do
      socket = clock_tick_handler(assigns)
      actual = assigns.tech_vuln_debt + 1
      expected = socket.assigns.tech_vuln_debt

      assert actual == expected
    end

    test "random bottom block is marked with vulnerability when tech_vuln_debt reaches vuln_threshold",
         %{assigns: assigns} do
      assigns = %{assigns | tech_vuln_debt: 79}
      socket = clock_tick_handler(assigns)

      assert Enum.any?(socket.assigns.bottom, fn {_point, {_x, _y, color}} ->
               color == :vuln_grey_yellow
             end)
    end

    test "tech_vuln_debt only increase if state is :playing", %{assigns: assigns} do
      # state :playing
      socket = clock_tick_handler(assigns)

      assert socket.assigns.tech_vuln_debt == assigns.tech_vuln_debt + 1

      # state :paused
      assigns = %{assigns | state: :paused}

      socket = clock_tick_handler(assigns)

      assert socket.assigns.tech_vuln_debt == assigns.tech_vuln_debt
    end

    test "vulnerability isn't added to block marked with license, attack and lawsuit",
         %{assigns: assigns} do
      bottom = %{
        {1, 20} => {1, 20, :lawsuit_brown_gold},
        {1, 19} => {1, 19, :lawsuit_brown_gold},
        {1, 18} => {1, 18, :license_grey_brown},
        {1, 17} => {1, 17, :attack_yellow_gold}
      }

      assigns = %{assigns | bottom: Map.merge(assigns.bottom, bottom)}

      socket = %Phoenix.LiveView.Socket{assigns: assigns}
      right_answer = Quadblockquiz.QnA.question(["qna"], "open_c2").correct

      wrong_answer =
        Enum.find(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"], fn guess ->
          guess != right_answer
        end)

      {:noreply, socket} =
        QuadblockquizWeb.TetrisLive.handle_event(
          "check_answer",
          %{"quiz" => %{"guess" => wrong_answer}},
          socket
        )

      refute Enum.any?(socket.assigns.bottom, fn {_point, {_x, _y, color}} ->
               color == :vuln_grey_yellow
             end)
    end
  end

  describe "Adding license" do
    test "random bottom block is marked with license when tech_lic_debt reaches lic_threshold", %{
      assigns: assigns
    } do
      assigns = %{assigns | tech_lic_debt: 81}
      socket = clock_tick_handler(assigns)

      assert Enum.any?(socket.assigns.bottom, fn {_point, {_x, _y, color}} ->
               color == :license_grey_brown
             end)
    end
  end

  describe "Incoming Block Vulnerability:" do
    test "incoming block is marked with vulnerability when brick count is evenly divided by threshold",
         %{conn: conn} do
      {:ok, view, _html} = live(conn, "/tetris")

      html = render_click(view, "start", %{contest: ""})
      # brick count is 1
      # vulnerability_new_brick_threshold: 7
      refute html =~ "vuln_grey_yellow"
    end
  end

  defp clock_tick_handler(assigns) do
    socket = %Phoenix.LiveView.Socket{assigns: assigns}

    {:noreply, socket} = QuadblockquizWeb.TetrisLive.handle_info(:tick, socket)
    socket
  end
end
