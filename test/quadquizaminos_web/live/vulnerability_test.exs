defmodule QuadquizaminosWeb.VulnerabilityTest do
  use QuadquizaminosWeb.ConnCase

  alias Quadquizaminos.QnA

  @bottom_vulnerability_value Application.get_env(:quadquizaminos, :bottom_vulnerability_value)

  describe "Vulnerability:" do
    setup do
      bottom = %{
        {1, 20} => {1, 20, :blue},
        {1, 19} => {1, 19, :blue},
        {1, 18} => {1, 18, :blue},
        {1, 17} => {1, 17, :blue}
      }

      assigns = %{
        bottom: bottom,
        brick: Quadquizaminos.Brick.new_random(),
        current_user: 40_000_000,
        gametime_counter: @bottom_vulnerability_value,
        score: 0,
        speed: 2,
        state: :playing,
        tick_count: 1,
        qna: QnA.question("open_c2"),
        row_count: 0,
        brick_count: 1
      }

      [assigns: assigns, bottom: bottom]
    end

    test "gametime_counter increases on clock tick", %{assigns: assigns} do
      socket = clock_tick_handler(assigns)

      assert socket.assigns.gametime_counter == @bottom_vulnerability_value + 1
    end

    test "random bottom block is marked with vulnerability when gametime_counter crosses interval set",
         %{assigns: assigns} do
      socket = clock_tick_handler(assigns)

      assert socket.assigns.gametime_counter > @bottom_vulnerability_value

      assert Enum.any?(socket.assigns.bottom, fn {_point, {_x, _y, color}} ->
               color == :vuln_grey_yellow
             end)
    end

    test "gametime_counter only increase if state is :playing", %{assigns: assigns} do
      # state :playing
      socket = clock_tick_handler(assigns)

      assert socket.assigns.gametime_counter == @bottom_vulnerability_value + 1

      # state :paused
      assigns = %{assigns | state: :paused}

      socket = clock_tick_handler(assigns)

      assert socket.assigns.gametime_counter == @bottom_vulnerability_value
    end

    test "gametime_counter is 0 if game state is :game_over or :starting", %{assigns: assigns} do
      # state :game_over
      assigns = %{assigns | state: :game_over}

      socket = clock_tick_handler(assigns)

      assert socket.assigns.gametime_counter == 0

      # state :starting
      assigns = %{assigns | state: :starting}

      socket = clock_tick_handler(assigns)
      assert socket.assigns.gametime_counter == 0
    end

    test "is added to bottom block on any wrong answer", %{
      assigns: assigns
    } do
      socket = %Phoenix.LiveView.Socket{assigns: assigns}
      right_answer = Quadquizaminos.QnA.question("open_c2").correct

      wrong_answer =
        Enum.find(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"], fn guess ->
          guess != right_answer
        end)

      {:noreply, socket} =
        QuadquizaminosWeb.TetrisLive.handle_event(
          "check_answer",
          %{"quiz" => %{"guess" => wrong_answer}},
          socket
        )

      assert Enum.any?(socket.assigns.bottom, fn {_point, {_x, _y, color}} ->
               color == :vuln_grey_yellow
             end)
    end

    test "vulnerability isn't added to block marked with license, attack and lawsuit",
         %{assigns: assigns} do
      bottom = %{
        {1, 20} => {1, 20, :lawsuit_brown_gold},
        {1, 19} => {1, 19, :lawsuit_brown_gold},
        {1, 18} => {1, 18, :license_grey_brown},
        {1, 17} => {1, 17, :attack_yellow_gold}
      }

      assigns = %{assigns | bottom: Map.merge(assigns.bottom, bottom)}

      socket = %Phoenix.LiveView.Socket{assigns: assigns}
      right_answer = Quadquizaminos.QnA.question("open_c2").correct

      wrong_answer =
        Enum.find(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"], fn guess ->
          guess != right_answer
        end)

      {:noreply, socket} =
        QuadquizaminosWeb.TetrisLive.handle_event(
          "check_answer",
          %{"quiz" => %{"guess" => wrong_answer}},
          socket
        )

      refute Enum.any?(socket.assigns.bottom, fn {_point, {_x, _y, color}} ->
               color == :vuln_grey_yellow
             end)
    end
  end

  defp clock_tick_handler(assigns) do
    socket = %Phoenix.LiveView.Socket{assigns: assigns}

    {:noreply, socket} = QuadquizaminosWeb.TetrisLive.handle_info(:tick, socket)
    socket
  end
end
